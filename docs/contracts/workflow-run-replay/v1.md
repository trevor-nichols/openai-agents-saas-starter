# Workflow Run Replay API Contract — v1

_Last updated: 2025-12-18_  
**Status:** Implemented (pre-release; additive evolution)  
**Event model (authoritative):** `docs/contracts/public-sse-streaming/v1.md` (`schema="public_sse_v1"`)

## 1) Purpose

Provide a **run-centric** API to replay the **exact browser transcript** a user saw during a workflow run.

The replay payload is a persisted sequence of `PublicSseEvent` frames (`public_sse_v1`) suitable for
deterministic UI reconstruction (messages, tool cards, refusals, reasoning summaries, citations,
attachments) without relying on step summaries.

## 2) Scope

### In scope
- Replay **only** the ledger frames that were originally emitted for a single `workflow_run_id`.
- Provide both:
  - **Paged JSON** for “fetch then render”, and
  - **SSE replay** for progressive hydration (same payloads, same semantics).

### Out of scope
- Defining/altering the public event contract (that is `public_sse_v1`).
- Exposing raw provider payloads to browsers.

## 3) Authorization & tenancy

Replay endpoints require:
- OAuth scope: `conversations:read`
- Tenant scoping:
  - Tenant is resolved from the authenticated token (and optionally down-scoped via headers).
  - The server MUST return `404` for a run that exists but is not within the caller’s tenant scope.

Headers (optional, but supported across the API surface):
- `X-Tenant-Id` (string UUID)
- `X-Tenant-Role` (`viewer | member | admin | owner`) — may only down-scope privileges

## 4) Endpoints

### 4.1 Paged replay (JSON)

`GET /api/v1/workflows/runs/{run_id}/replay/events`

Query params:
- `limit` (default `500`, min `1`, max `1000`)
- `cursor` (optional, opaque)

Response (v1 shape):

```json
{
  "workflow_run_id": "run_...",
  "conversation_id": "uuid",
  "items": [ { "schema": "public_sse_v1", "kind": "...", "...": "..." } ],
  "next_cursor": "opaque-or-null"
}
```

Semantics:
- `items[]` are **ordered** and represent the persisted `public_sse_v1` frames for that run.
- Clients MUST apply ordering/patch semantics as defined by the event contract:
  - transcript ordered by `output_index`
  - updates applied by `item_id` (+ `content_index` for message parts)
  - tool linkage by `tool_call_id`
- Pagination is **keyset-based**; `cursor` indicates “start after the last returned ledger row”.

Errors:
- `404` — run not found (or tenant mismatch)
- `409` — run exists but is missing a linked `conversation_id` (data integrity issue)
- `400` — invalid `cursor` (malformed or not valid for this run slice)

### 4.2 Replay stream (SSE)

`GET /api/v1/workflows/runs/{run_id}/replay/stream`

Query params:
- `cursor` (optional, opaque)

Response:
- `Content-Type: text/event-stream`
- Frames:

```
data: <PublicSseEvent JSON>\n\n
```

Semantics:
- Emits the same `PublicSseEvent` payloads as `replay/events`, in the same order.
- This is a **replay**; the stream does not synthesize new events.
- The stream ends naturally after the last event for the run slice.

Errors:
- Same as `replay/events`. Cursor validation MUST happen before the first byte is written.

## 5) Cursor semantics (v1)

- `cursor` is opaque; clients MUST NOT parse or construct it.
- Cursors are scoped to the run’s ledger slice:
  - the server MUST reject cursors that do not belong to the requested `run_id` with `400`.
- `next_cursor=null` indicates end-of-run replay (no more events).

## 6) Attachment durability requirements

Replay UX MUST NOT rely on long-lived presigned URLs.

Rules:
- Replay frames may include attachments in terminal `final.attachments` and/or tool events.
- Attachments MUST carry stable identifiers (`object_id`) sufficient to re-resolve a download.
- If an attachment includes a `url`, it is best-effort and MAY be expired.
- Clients SHOULD re-presign (via the storage API) when a user attempts to download an attachment
  and the URL is missing/expired.

## 7) Compatibility & versioning

- This API contract is **v1** and assumes the `public_sse_v1` event schema.
- Any incompatible replay API changes MUST:
  - introduce a new versioned contract doc, and
  - be shipped as a coordinated backend+web update (pre-release policy is additive-only where possible).
