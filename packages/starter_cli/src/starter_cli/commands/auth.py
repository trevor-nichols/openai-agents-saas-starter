from __future__ import annotations

import argparse
import json
import os
import sys
from typing import TYPE_CHECKING, Any, TypeAlias

import httpx

from starter_cli.core import CLIContext, CLIError, build_context
from starter_cli.core.context import should_skip_env_loading
from starter_cli.services.security import build_vault_headers, rotate_signing_keys

# `_SubParsersAction` is not parametrized at runtime on Python 3.11, so provide a
# typed alias only when running type checkers.
if TYPE_CHECKING:
    ParserSubparsers: TypeAlias = argparse._SubParsersAction[argparse.ArgumentParser]
else:  # pragma: no cover - runtime stub
    ParserSubparsers = argparse._SubParsersAction


def register(subparsers: ParserSubparsers) -> None:
    auth_parser = subparsers.add_parser("auth", help="Authentication utilities.")
    auth_subparsers = auth_parser.add_subparsers(dest="auth_command")

    _register_tokens_command(auth_subparsers)
    _register_keys_command(auth_subparsers)
    _register_jwks_command(auth_subparsers)


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="auth",
        description="Authentication utilities for api-service.",
    )
    subparsers = parser.add_subparsers(dest="command")
    _register_tokens_command(subparsers)
    _register_keys_command(subparsers)
    _register_jwks_command(subparsers)
    return parser


def _register_tokens_command(subparsers: ParserSubparsers) -> None:
    tokens_parser = subparsers.add_parser("tokens", help="Token management commands.")
    tokens_subparsers = tokens_parser.add_subparsers(dest="tokens_command")

    issue_parser = tokens_subparsers.add_parser(
        "issue-service-account",
        help="Issue a refresh token for a service account.",
    )
    issue_parser.add_argument("--account", "-a", required=True, help="Service-account slug.")
    issue_parser.add_argument(
        "--scopes",
        "-s",
        required=True,
        help="Comma-separated list of scopes.",
    )
    issue_parser.add_argument("--tenant", "-t", help="Tenant UUID for scoped accounts.")
    issue_parser.add_argument(
        "--lifetime",
        type=int,
        help="Optional refresh token lifetime in minutes.",
    )
    issue_parser.add_argument(
        "--fingerprint",
        help="Optional machine or pipeline identifier for auditing.",
    )
    issue_parser.add_argument(
        "--force",
        action="store_true",
        help="Force minting a new token even if an active token exists.",
    )
    issue_parser.add_argument(
        "--output",
        "-o",
        choices={"json", "text", "env"},
        default=DEFAULT_OUTPUT_FORMAT,
        help=(
            "Output format (json, text, env). Defaults to AUTH_CLI_OUTPUT or json when unset."
        ),
    )
    issue_parser.add_argument(
        "--base-url",
        default=DEFAULT_BASE_URL,
        help="AuthService base URL (defaults to AUTH_CLI_BASE_URL or http://127.0.0.1:8000).",
    )
    issue_parser.set_defaults(handler=handle_issue_service_account)


def _register_keys_command(subparsers: ParserSubparsers) -> None:
    keys_parser = subparsers.add_parser("keys", help="Signing key management.")
    keys_subparsers = keys_parser.add_subparsers(dest="keys_command")

    rotate_parser = keys_subparsers.add_parser(
        "rotate",
        help="Generate a new Ed25519 keypair and store it as the active key.",
    )
    rotate_parser.add_argument(
        "--kid",
        help="Optional key identifier; defaults to autogenerated Ed25519 prefix.",
    )
    rotate_parser.set_defaults(handler=handle_keys_rotate)


def _register_jwks_command(subparsers: ParserSubparsers) -> None:
    jwks_parser = subparsers.add_parser("jwks", help="JWKS utilities.")
    jwks_subparsers = jwks_parser.add_subparsers(dest="jwks_command")

    print_parser = jwks_subparsers.add_parser("print", help="Print the current JWKS payload.")
    print_parser.set_defaults(handler=handle_jwks_print)


def handle_issue_service_account(
    args: argparse.Namespace,
    ctx: CLIContext | None = None,
) -> int:
    ctx = _ensure_context(ctx)
    payload = _build_issue_payload(args)
    try:
        response = _post_issue_service_account(base_url=args.base_url, payload=payload, ctx=ctx)
    except CLIError as exc:
        print(f"error: {exc}", file=sys.stderr)
        return 1
    output = _render_issue_output(response, args.output)
    print(output)
    return 0


def handle_keys_rotate(args: argparse.Namespace, ctx: CLIContext | None = None) -> int:
    ctx = _ensure_context(ctx)
    console = ctx.console
    result = rotate_signing_keys(ctx, kid=args.kid)
    console.success("Generated new Ed25519 key pair.", topic="auth", stream=console.err_stream)
    print(json.dumps(result.to_dict(), indent=2))
    return 0


def handle_jwks_print(_: argparse.Namespace, ctx: CLIContext) -> int:
    ctx = _ensure_context(ctx)
    settings = ctx.require_settings()
    configure_key_storage_secret_manager(ctx)

    try:
        keyset = load_keyset(settings)
    except KeyStorageError as exc:  # pragma: no cover - depends on env
        raise CLIError(str(exc)) from exc

    document = keyset.materialize_jwks()
    print(json.dumps(document.payload, indent=2))
    return 0


def _build_issue_payload(args: argparse.Namespace) -> dict[str, Any]:
    scopes = _parse_scopes(args.scopes)
    payload: dict[str, Any] = {
        "account": args.account,
        "scopes": scopes,
        "tenant_id": args.tenant,
        "lifetime_minutes": args.lifetime,
        "fingerprint": args.fingerprint,
        "force": args.force,
    }
    return payload


def _parse_scopes(raw_scopes: str) -> list[str]:
    scopes = [scope.strip() for scope in raw_scopes.split(",") if scope.strip()]
    if not scopes:
        raise CLIError("At least one scope must be provided via --scopes.")
    return scopes


def _post_issue_service_account(
    *,
    base_url: str,
    payload: dict[str, Any],
    ctx: CLIContext,
) -> dict[str, Any]:
    url = f"{base_url.rstrip('/')}/api/v1/auth/service-accounts/issue"
    settings = ctx.optional_settings()
    auth_header, extra_headers = build_vault_headers(payload, settings)
    headers = {"Authorization": auth_header, **extra_headers}

    with httpx.Client(timeout=10.0) as client:
        response = client.post(url, json=payload, headers=headers)

    if response.status_code >= 400:
        try:
            body = response.json()
            detail = body.get("detail") or body.get("message") or body.get("error")
        except Exception:
            detail = response.text
        raise CLIError(f"Issuance failed ({response.status_code}): {detail}")

    document = response.json()
    ctx.console.success(
        "Service-account token issued.",
        topic="auth",
        stream=ctx.console.err_stream,
    )
    return document


def _render_issue_output(data: dict[str, Any], fmt: str) -> str:
    if fmt == "json":
        return json.dumps(data, indent=2)
    if fmt == "env":
        return "\n".join([f"AUTH_REFRESH_TOKEN={data['refresh_token']}"])

    lines = [
        f"Account: {data.get('account')}",
        f"Scopes: {', '.join(data.get('scopes', []))}",
        f"Issued At: {data.get('issued_at')}",
        f"Expires At: {data.get('expires_at')}",
        f"Tenant ID: {data.get('tenant_id') or 'global'}",
        f"Token Use: {data.get('token_use')}",
        f"Key ID: {data.get('kid')}",
        "",
        "Refresh Token:",
        data.get("refresh_token", ""),
    ]
    return "\n".join(lines)


def _ensure_context(ctx: CLIContext | None) -> CLIContext:
    if ctx is not None:
        return ctx
    new_ctx = build_context()
    if not should_skip_env_loading():
        new_ctx.load_environment(verbose=False)
    return new_ctx


__all__ = [
    "register",
    "build_parser",
    "handle_issue_service_account",
    "handle_keys_rotate",
    "handle_jwks_print",
]
DEFAULT_OUTPUT_FORMAT = os.getenv("AUTH_CLI_OUTPUT", "json").lower()
DEFAULT_BASE_URL = os.getenv("AUTH_CLI_BASE_URL", "http://127.0.0.1:8000")
